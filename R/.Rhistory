data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
plot.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
plot.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
env <- perf(plot.env)
env
hist <- perf(plot.hist)
hist
full  <- perf(plot.full)
full
################################################################################
# Author: Petr Keil
# Email: pkeil@seznam.cz
# Date: Dec 7 2017
################################################################################
# Description: Here is where I perform the deviance partitioning. In short, model
# REALM is fitted to different subset of the data, and the deviance explained by
# environmental variables or biogeographic realms is calculated.
# Also, here is where the PCA plots of the environmental conditions within realms
# are calculated.
################################################################################
# clean the workspace and load the libraries
source("0_libraries_functions_settings.r")
# load the data
source("4.1_Data_loading_standardization_and_centering.r")
################################################################################
# THE DEVIANCE PARTITIONING
################################################################################
# define the family that will be used in the exercise (so that we can easily
# also check the effect of this on the obtained partitions)
fam = "nb"
# function that extracts R2 and deviance explained from a model object
perf <- function(obj)
{
res <- c(dev.exp = summary(obj)$dev.exp,
r.sq = summary(obj)$r.sq)
return(res)
}
DAT.north <- DAT[DAT$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic"),]
DAT.north <- dplyr::filter(.data=DAT,
DAT$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic"))
######################################################################
# DEVIANCE PARTITIONING - MODEL REALM, PLOT GRAIN, NORTHERN HEMISPHERE
######################################################################
plot.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
plot.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
plot.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Plot",],
family="nb")
env <- perf(plot.env)
env
hist <- perf(plot.hist)
hist
full  <- perf(plot.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
7+37+38+18
##############################
# DEVIANCE PARTITIONING - MODEL REALM, COUNTRY GRAIN, NORTHERN HEMISPHERE
#########################################################################
cntr.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.north[DAT.north$DAT_TYPE=="Country",],
family="nb")
cntr.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Country",],
family="nb")
cntr.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.north[DAT.north$DAT_TYPE=="Country",],
family="nb")
env <- perf(cntr.env)
env
hist <- perf(cntr.hist)
hist
full  <- perf(cntr.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
13+48+23+16
DAT.north <- DAT[DAT$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic"),]
DAT.north <- dplyr::filter(.data=DAT,
DAT$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic"))
################################################################################
# DEVIANCE PARTITIONING, TROPICS
################################################################################
DAT.south <- DAT[DAT$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic") == FALSE,]
##########################################################
# DEVIANCE PARTITIONING - MODEL REALM, PLOT GRAIN, TROPICS
##########################################################
plot.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
plot.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
plot.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
env <- perf(plot.env)
env
hist <- perf(plot.hist)
hist
full  <- perf(plot.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
4+33+37+26
cntr.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
cntr.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
cntr.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
env <- perf(cntr.env)
env
hist <- perf(cntr.hist)
hist
full  <- perf(cntr.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
24+25+42+9
plot.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
plot.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
plot.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Plot",],
family="nb")
env <- perf(plot.env)
env
hist <- perf(plot.hist)
hist
full  <- perf(plot.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
#############################################################
# DEVIANCE PARTITIONING - MODEL REALM, COUNTRY GRAIN, TROPICS
#############################################################
cntr.hist <- gam(S ~ REALM + poly(Area_km,3):REALM,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
cntr.env <- gam(S ~   Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
cntr.full <- gam(S ~   REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
ISLAND + ISLAND:Area_km,
data=DAT.south[DAT.south$DAT_TYPE=="Country",],
family="nb")
env <- perf(cntr.env)
env
hist <- perf(cntr.hist)
hist
full  <- perf(cntr.full)
full
# independent - environment
indep.env = full - hist
indep.env
# independent - history
indep.hist <- full - env
indep.hist
# overlap
overlap = full - (indep.hist + indep.env)
overlap
# unexplained
1 - full
################################################################################
# Author: Petr Keil
# Email: pkeil@seznam.cz
# Date: April 26 2018
################################################################################
# Description: Here is where model SMOOTH is used to generate predictions to the
# regular global network of 1 ha plots, and to the grid of large hexagons.
################################################################################
# clean the workspace and load the libraries
source("0_libraries_functions_settings.r")
################################################################################
### Read, transform and scale the data
# read the data
pts <- read.csv(file="../Data/GRIDS/Fine_points_with_environment.csv")
grid5 <- readOGR(dsn = "../Data/GRIDS", layer = "hex5_with_environment")
grid5 <- spTransform(x = grid5, CRSobj = WGS84)
# -----------------------------------------
pts$Tree_dens <- (pts$TREE_DENS + 1) / pts$A # calculate tree density (note the x+1 step!!)
pts <- data.frame(pts,
Area_km = 0.01,
min_DBH = 0,
ELONG = 1,
DAT_TYPE = "Plot")
# tree density at the grid level
grid5$Tree_dens <- (grid5$TREE_DENS + 1) / grid5$LandArea
grid5@data <- data.frame(grid5@data,
min_DBH = 0,
ELONG = 1,
DAT_TYPE = "Country")
# -----------------------------------------
pts <- dplyr::select(pts, Area_km, Tree_dens, min_DBH,
GPP, ANN_T, ISO_T, MIN_P, P_SEAS, ALT_DIF, ELONG,
ISLAND = ISL_LS, Lat, Lon, DAT_TYPE) %>%
mutate(Area_km = log(Area_km), Tree_dens=log(Tree_dens))
grid5.dat <- dplyr::select(grid5@data, Area_km = LandArea, Tree_dens, min_DBH,
GPP, ANN_T, ISO_T, MIN_P, P_SEAS, ALT_DIF, ELONG,
ISLAND = ISL_LS, Lat, Lon, DAT_TYPE) %>%
mutate(Area_km = log(Area_km), Tree_dens=log(Tree_dens))
# get the scaling constants that were used to scale the raw plot and country data:
scal.tab <- read.csv("scale_tab.csv")
scal.tab <- scal.tab[scal.tab$var %in% c("ET","WARM_T") == FALSE,]
# scale the grid data in the same way as the original data
pts[,1:10] <- scale(pts[,1:10],
center = scal.tab$centr,
scale = scal.tab$scale)
grid5.dat[,1:10] <- scale(grid5.dat[,1:10],
center = scal.tab$centr,
scale = scal.tab$scale)
################################################################################
### Make the predictions
# load the saved SMOOTH model that will be used for the global predictions
library(mgcv)
load("../Models/gam_SMOOTH.Rdata")
################################################################################
### Predictions in hexagons
# predict S from the model SMOOTH
grid.pred.S <- predict(gam.SMOOTH,
newdata = grid5.dat,
type="response")
grid.preds.S <- round(grid.pred.S, 2)
# predict the regional effect from model SMOOTH
grid.pred.smth <- predict.gam(gam.SMOOTH,
type = "terms",
newdata = grid5.dat)[,"s(Lat,Lon):DAT_TYPECountry"]
# merge with the original grid
grid5@data <- data.frame(grid5@data, S = grid.pred.S, smooth.country = grid.pred.smth)
grid5@data$id <- as.character(grid5@data$id)
# remove cells with little land area
good.cells <-  grid5@data$LandArea / grid5@data$CellArea > 0.5
good.cells[is.na(good.cells)] <- FALSE
grid5 <- grid5[good.cells,]
# remove cells with 0 or NA species predicted
good.cells <- grid5@data$S > 1
good.cells[is.na(good.cells)] <- FALSE
grid5 <- grid5[good.cells, ]
################################################################################
### Predictions in 1 ha plots
# predict S in the plots from the SMOOTH model
plot.pred.S <- predict(gam.SMOOTH,
newdata = pts,
type="response")
plot.pred.S <- round(plot.pred.S, 2)
# predict region effects in the plots from the SMOOTH model
plot.pred.smth <- predict.gam(gam.SMOOTH,
type = "terms",
newdata = pts)[,"s(Lat,Lon):DAT_TYPEPlot"]
# put all together
plot.preds <- data.frame(pts,
S = as.numeric(plot.pred.S),
smooth.plot = plot.pred.smth)
# remove predictions of S < 0.8 (an arbitrarily selected threshold)
plot.preds$S[plot.preds$S < 0.8] <- NA
plot.preds <- plot.preds[rowSums(is.na(plot.preds)) == 0,]
# put predictions to a spatial object
plot.preds <- SpatialPointsDataFrame(coords = data.frame(plot.preds$Lon, plot.preds$Lat),
data = plot.preds,
proj4string = CRS(WGS84))
# ------------------------------------------------------------------------------
# calculate BETA DIVERSITY for PLOTS
# extract S values from the hexagonal grid to the points
gamma <- over(x=plot.preds, y=grid5)[,c("S", "ALT_DIF", "smooth.country")]
names(gamma) <- c("gamma", "ALT_DIF_grid", "smooth.country")
# calculate beta diversity per plot
plot.preds@data <- data.frame(plot.preds@data, gamma) %>%
mutate(beta = gamma/S, reg.beta = exp(smooth.country)/exp(smooth.plot))
# ------------------------------------------------------------------------------
# write out data with no NA values
write.csv(plot.preds@data,
file="../Data/GRIDS/Fine_points_with_predictions.csv", row.names=FALSE)
# ------------------------------------------------------------------------------
# transform the data for fancy plotting
plot.preds.ml <- spTransform(plot.preds, CRSobj = MOLLWEIDE)
plot.preds.ml <- data.frame(plot.preds.ml@data,
data.frame(X=coordinates(plot.preds.ml)[,1],
Y=coordinates(plot.preds.ml)[,2]))
grid5.ml <- spTransform(grid5, CRSobj=MOLLWEIDE)
grid5.mlf <- tidy(grid5.ml, region="id")
grid5.mlf <- left_join(x=grid5.mlf, y=grid5.ml@data, by="id")
nrow(grid5)
nrow(plot.preds)
################################################################################
source("0_libraries_functions_settings.r")
source("4.1_Data_loading_standardization_and_centering.r")
summary(DAT)
################################################################################
# Author: Petr Keil
# Email: pkeil@seznam.cz
# Date: April 26 2018
################################################################################
# Description: THIS IS WHERE WE DO THE ANALYSIS WITH JUST A SUBSET OF THE DATA,
# OR THE SO CALLED 'SENSITIVITY ANALYSIS' (SEE THE METHODS).
# THE GOAL IS TO MAKE SURE THAT THE RESULTS ARE ROBUST TO DATA SOURCES
# AND TO DIFFERENT DEFINITIONS OF TREES.
# THE PROTOCOL IS THE SAME AS IN THE FULL DATASET, ONLY THE BASE DATA ARE SMALLER.
################################################################################
# 0. LOAD THE DATA AND THE PACKAGES
################################################################################
# clean the workspace and load the libraries
source("0_libraries_functions_settings.r")
# ------------------------------------------------------------------------------
# load the data
PLT <- read.csv("../Data/Main_dataset_subset.csv")
################################################################################
# 1. PREPARE THE DATA FOR THE ANALYSES
################################################################################
# cakculate tree density (note the x+1 step!!)
PLT$Tree_dens <- (PLT$N + 1) / PLT$Area_km
# select only the variables of interest from the larger data.frame
DAT <- dplyr::select(PLT, S, Area_km, Tree_dens, min_DBH=min_DBH_cm,
GPP, ET, ANN_T, WARM_T, ISO_T, MIN_P, P_SEAS, ALT_DIF,
ISLAND = ISL_LS, REALM=REALM_PK, Lat, Lon, DAT_TYPE, Loc_ID)
# order the data frame by regions and area
DAT <- DAT[order(DAT$REALM),]
# transform area and tree density
DAT$Area_km <- log(DAT$Area_km)
DAT$Tree_dens <- log(DAT$Tree_dens)
# remove NAs
DAT <- DAT[rowSums(is.na(DAT)) == 0,]
# mean and sd of Area (will be used later to bring these to their origina scale)
A.mean <- mean(DAT$Area_km)
A.sd <- sd(DAT$Area_km)
# means and sd of the rest of the variables
centr <- attributes(scale(DAT[,2:12]))$'scaled:center'
scale <- attributes(scale(DAT[,2:12]))$'scaled:scale'
scale.tab <- data.frame(var=names(centr), centr, scale)
write.csv(scale.tab, file="scale_tab.csv", row.names = FALSE)
# do the actual scaling
DAT[,2:12] <- scale(DAT[,2:12])
summary(DAT)
