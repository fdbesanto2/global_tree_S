scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
ggtitle("B") + theme_minimal() +
#labs(subtitle = expression(S[plot] ~ "(richness at the plot grain)")) +
xlab("") + ylab("") + blank.theme
tiff("../Figures/Fig_1_richness_map.tif", width=2000, height=2100, res=350,
compression = "lzw")
grid.arrange(s.cntr, s.plot, ncol=1, nrow=2)
dev.off()
# ------------------------------------------------------------------------------
# BIOGEOGRAPHIC REALMS
blank.theme <- theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
# save to a file
png("../Figures/Fig_S9_realms_map.png", width=2300, height=1000, res=200)
realm.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=3, colour="black") +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
# save to a file
png("../Figures/realms_map.png", width=2300, height=1000, res=200)
realm.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=1, colour="black") +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
# save to a file
png("../Figures/realms_map_small.png", width=2400, height=1000, res=400)
realm.plot.small <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
# ------------------------------------------------------------------------------
# ISLANDS
# save to a file
png("../Figures/Fig_S8_islands.png", width=2300, height=1000, res=200)
isl.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
#geom_hline(yintercept = 0, colour="black", size=0.2) +
# geom_polygon(data=LINES,  aes(long, lat, group=group),
#             colour="black", size=0.2) +
geom_polygon(aes(fill=as.factor(ISLAND)), colour="darkgrey", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=3, colour="black") +
scale_fill_brewer(palette = "Set2", name="Island") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
xlab("") + ylab("") + theme_minimal() + blank.theme
isl.plot
dev.off()
# ------------------------------------------------------------------------------
# NORTHERN AND SOUTHERN HEMISPHERES
# save to a file
png("../Figures/hemispheres_map.png", width=1800, height=1000, res=200)
hemi.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
#geom_hline(yintercept = 0, colour="black", size=0.2) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(aes(fill=as.factor(Hemisphere)), colour="darkgrey", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=3, colour="black") +
scale_fill_brewer(palette = "Reds", name="", type=qual) +
scale_x_continuous(limits = c(-13000000, 16000000)) +
xlab("") + ylab("") + theme_minimal() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
panel.background = element_blank(),
axis.text.x=element_blank(),
axis.text.y=element_blank(),
legend.position="none") + blank.theme
hemi.plot
dev.off()
################################################################################
# 7. FIT THE MODELS IN STAN, using 'brms' function 'brm'
################################################################################
# Beware, this will take 30 min to run (approximately) on a 2GHz 2-core laptop.
# YOU CAN SKIP THIS AND LOAD THE FITTED MODELS IN STEP 8!!!
brm.SMOOTH <- brm(SMOOTH.formula, family="negbinomial", data=DAT,
cores=3,
seed=12355,
chains=3, iter=3000, warmup=1000, thin=10)
# save to a file
save(brm.SMOOTH , file="../STAN_models/brms_SMOOTH.RData")
brm.REALM <- brm(REALM.formula, family="negbinomial", data=DAT,
cores=3,
seed=12355,
chains=3, iter=3000, warmup=1000, thin=10)
# save to a file
save(brm.REALM, file="../STAN_models/brms_REALM.RData")
################################################################################
# 8. LOAD THE FITTED STAN OBJECTS
################################################################################
load("../STAN_models/brms_SMOOTH.RData")
load("../STAN_models/brms_REALM.RData")
################################################################################
# 9. DISSECTING THE STAN MODEL RESULTS
################################################################################
# are the predictions from the brms and mgcv models the same?
prd.gam <- predict(gam.SMOOTH, type="response")
prd <- predict(brm.SMOOTH, newdata=DAT)[,'Estimate']
plot(prd, prd.gam)
abline(a=0, b=1)
# ------------------------------------------------------------------------------
# Observed vs predicted values with the full Bayesian uncertainty
pred.REALM.brm <- predict(brm.REALM, type="response",
newdata = DAT, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
pred.REALM.brm <- data.frame(pred.REALM.brm,
S = DAT$S,
grain = DAT$DAT_TYPE,
model = "Model REALM")
pred.SMOOTH.brm <- predict(brm.SMOOTH, type="response",
newdata = DAT, probs = c(0.025, 0.25, 0.5, 0.75, 0.975))
pred.SMOOTH.brm <- data.frame(pred.SMOOTH.brm,
S = DAT$S,
grain = DAT$DAT_TYPE,
model = "Model SMOOTH")
pred.brm <- rbind(pred.REALM.brm, pred.SMOOTH.brm)
obs.pred.brm <- ggplot(pred.brm, aes(x = S, y = X50.ile)) +
geom_linerange(aes(ymin = X2.5.ile, ymax = X97.5.ile, colour = grain), alpha = 0.2) +
geom_linerange(aes(ymin = X25.ile, ymax = X75.ile, colour = grain), size=1, alpha = 0.4) +
#geom_linerange(aes(ymin = X2.5.ile, ymax = X97.5.ile), colour = "lightgrey") +
#geom_linerange(aes(ymin = X25.ile, ymax = X75.ile), colour = "darkgrey", size=1) +
geom_point(aes(colour=grain), shape = 1) +
#geom_point(colour = "darkgrey", shape = 1) +
xlab("log10 Observed S") + ylab("log10 Predicted S") +
geom_abline(intercept = 0, slope = 1, colour="black") + theme_bw() +
scale_x_continuous(trans = "log10", breaks = c(1, 10, 100, 1000, 10000)) +
scale_y_continuous(trans = "log10", breaks = c(1, 10, 100, 1000, 10000)) +
facet_grid(.~model) +
labs(size = "log10 Area [km]") + labs(colour = "grain") +
guides(colour = guide_legend(override.aes = list(size=4, shape=19), title="grain"))
obs.pred.brm
# export the figure
png("../Figures/Fig_obs_vs_pred.png", width=2000, height=950, res=250)
obs.pred.brm
dev.off()
# ------------------------------------------------------------------------------
# TRACEPLOTS and CATERPILLAR PLOTS of model parameters
pars.REALM <- rownames(data.frame(summary(brm.REALM$fit)[1]))[1:46]
pars.SMOOTH <- rownames(data.frame(summary(brm.SMOOTH$fit)[1]))[1:51]
# traceplots - this indicate if the convergence is good (which it is)
# save to a file
png("../Figures/traceplot_REALM.png", width = 2000, height=2000, res=150)
rstan::traceplot(brm.REALM$fit, pars=pars.REALM)
dev.off()
# save to a file
png("../Figures/traceplot_SMOOTH.png", width = 2000, height=2000, res=150)
rstan::traceplot(brm.SMOOTH$fit, pars=pars.SMOOTH)
dev.off()
# caterpillar plots
# save to a file
png("../Figures/caterpillar_REALM.png", width = 2000, height=2000, res=150)
rstan::plot(brm.REALM$fit, pars=pars.REALM)
dev.off()
# this is how to get the data out:
standata(brm.REALM)
# ------------------------------------------------------------------------------
# CORRELATION MATRIX OF MODEL PARAMETERS
mcmc_pairs(x = as.mcmc(brm.REALM), pars = c("min_DBH", "ANN_T"))
# ------------------------------------------------------------------------------
# brm.SMOOTH results
# ------------------------------------------------------------------------------
all.varnames.SMOOTH <- rownames(summary(brm.SMOOTH)$fixed)
data.frame(all.varnames.SMOOTH)
all.vars.SMOOTH <- standata(brm.SMOOTH)$X
all.splines.SMOOTH <- standata(brm.SMOOTH)$Zs_2_1
pars.country.splines.SMOOTH <- summary(brm.SMOOTH$fit)$summary[,'50%'][26:38]
pars.plot.splines.SMOOTH <- summary(brm.SMOOTH$fit)$summary[,'50%'][39:51]
pars.envivars.SMOOTH <- summary(brm.SMOOTH$fit)$summary[,'50%'][39:51]
SMOOTH.area.id <- c(2:4)
area.varnames.SMOOTH <- all.varnames.SMOOTH[SMOOTH.area.id]
area.parnames.SMOOTH <- paste("b", area.varnames.SMOOTH, sep="_")
area.vars.SMOOTH <- model.matrix.gam(gam.SMOOTH)[,SMOOTH.area.id]
# ------------------------------------------------------------------------------
# brm.REALM results
# ------------------------------------------------------------------------------
all.varnames.REALM <- rownames(summary(brm.REALM)$fixed)
data.frame(all.varnames.REALM)
all.vars.REALM <- model.matrix.gam(gam.REALM)
all.pars.REALM <- summary(brm.REALM)$fixed[,'Estimate']
REALM.hist.id <- c(2:7, 17:37)
hist.varnames.REALM <- all.varnames.REALM[REALM.hist.id]
hist.parnames.REALM <- paste("b", hist.varnames.REALM, sep="_")
hist.vars.REALM <- model.matrix.gam(gam.REALM)[,REALM.hist.id]
# ------------------------------------------------------------------------------
# EXTRACT ONE PARAMETER FROM THE BRMS FITTED OBJECT (BY NAME)
extract.par <- function(par.name, brm.fit)
{
n.iter <- summary(brm.fit)$iter
n.chains <- summary(brm.fit)$chains
n.thin <- summary(brm.fit)$thin
n.warm <- summary(brm.fit)$warmup
res <- list()
for(chain in 1:n.chains){
one.chain <- brm.fit$fit@sim$samples[[chain]][par.name][[1]]
res[[chain]] <- one.chain[((n.warm/n.thin)+1):length(one.chain)]
}
res <- unlist(res)
return(res)
}
# b <- extract.par("b_Intercept", brm.REALM)
# EXTRACT MULTIPLE PARAMETERS FROM THE BRMS FITTED OBJECT (BY NAMES)
extract.pars <- function(par.names, brm.fit)
{
res <- list()
for(par in par.names){
res[[par]] <- extract.par(par, brm.fit)
}
return(res)
}
#bb <- extract.pars(hist.parnames.REALM, brm.REALM)
# CHOOSE ONE SAMPLING ITERATION AND SAMPLE PARAMETER VALUES FROM THAT
draw.one <- function(par.list, i){
myfun <- function(x, i) x[i]
unlist(lapply(par.list, FUN=myfun, i=i))
}
#bbb <- draw.one(bb, 1)
# CALCULATE PREDICTION FOR EACH PARAMETER DRAW IN THE CHAIN
draw.all <- function(par.names, vars, brm.fit, probs=c(0.025, 0.25, 0.5,0.75, 0.975))
{
B <- extract.pars(par.names, brm.fit)
N <- length(B[[1]])
res <- matrix(nrow=nrow(vars), ncol=N)
for(i in 1:N){
b <- draw.one(B, i=i)
res[,i] <- vars %*% b
}
require(matrixStats)
res <- matrixStats::rowQuantiles(res, probs=probs)
return(res)
}
################################################################################
# 10. SUMMARIZE THE REALM PREDICTIONS
################################################################################
prd.brm.REALM <- all.vars.REALM %*% all.pars.REALM
#prd.brm.REALM <- predict(brm.REALM, newdata=DAT, type="link")[,'Estimate']
res.brm.REALM <- prd.brm.REALM - log(DAT$S)
prd.history.REALM <- draw.all(par.names = hist.parnames.REALM,
vars = hist.vars.REALM,
brm.fit = brm.REALM)
resid.REALM <- prd.history.REALM[,'50%'] + res.brm.REALM
HIST <- data.frame(prd.history.REALM, DAT, resid.REALM)
p.hist.multi <- ggplot(HIST, aes(log10(exp(Area_km*A.sd + A.mean)), X50.)) +
geom_point(aes(log10(exp(Area_km*A.sd + A.mean)), resid.REALM),
colour="grey", shape=1) +
geom_linerange(aes(ymin=X2.5., ymax=X97.5., colour=REALM), alpha=0.5) +
geom_linerange(aes(ymin=X25., ymax=X75., colour=REALM), size=1) +
# geom_hline(yintercept = 0, linetype=2) +
geom_line(aes(colour=REALM)) +
xlab(expression(log[10] ~ "Area" ~ (km^2))) +
ylab("Region effect") +
scale_colour_brewer(palette = "Dark2", name="Realm") +
theme_bw()  +
theme(legend.position="none") +
#ggtitle("B") +
facet_grid(. ~ REALM)
p.hist.multi
theme.legend <- theme(legend.position="right",#c(0.25,0.8),
legend.title = element_blank(),
legend.background = element_rect(fill="white",
size=0.2, linetype="solid",
colour ="black"))
p.hist.single <- ggplot(HIST, aes(log10(exp(Area_km*A.sd + A.mean)), X50.)) +
geom_linerange(aes(ymin=X2.5., ymax=X97.5., colour=REALM), alpha=0.4) +
geom_linerange(aes(ymin=X25., ymax=X75., colour=REALM), size=1) +
geom_line( aes(colour=REALM)) +
scale_colour_brewer(palette = "Dark2", name="Realm") +
xlab(expression(log[10] ~ "Area" ~ (km^2))) +
ylab("Region effect") +
# ggtitle("B") +
theme_bw()+
theme.legend +
theme(plot.title = element_text(hjust = -0.125))
p.hist.single
# Figure for the main text - save to a file
tiff("../Figures/Fig_3_region_effects_REALM.tif", width=1800, height=2700, res=400,
compression = "lzw")
grid.arrange(realm.plot + ggtitle("A") +theme(legend.position="none") ,
p.hist.single,
heights=c(0.6,1),
nrow=2)
dev.off()
pdf("../Figures/Fig_3_region_effects_REALM.pdf", width=6, height=4)
p.hist.single
dev.off()
# Figure for supplementary material - save to a file
tiff("../Figures/Fig_S3_region_effects_REALM_separate.tif",
width=2500, height=600, res=250,
compression = "lzw")
p.hist.multi
dev.off()
################################################################################
# 11. TRIPHASIC SAR CURVE FROM THE SMOOTH PREDICTIONS
################################################################################
prd.area.SMOOTH <- draw.all(par.names = area.parnames.SMOOTH,
vars = area.vars.SMOOTH,
brm.fit = brm.SMOOTH)
partial.res.area <- prd.area.SMOOTH + residuals(gam.SMOOTH)
AREA <- data.frame(prd.area.SMOOTH, DAT, partial.resid = partial.res.area)
# save to a file
png("../Figures/Fig_S3_SAR_SMOOTH.png", width=1500, height=1500, res=500)
ggplot(AREA, aes(x=log10(exp(Area_km*A.sd + A.mean)), y=X50.)) +
geom_point(aes(x=log10(exp(Area_km*A.sd + A.mean)), y=partial.resid.50.),
color="grey", shape=1) +
geom_line(size=0.8) +
ylab("Partial effect of Area") +
xlab(expression(log[10] ~ "Area" ~ (km^2))) +
geom_ribbon(aes(ymin=X2.5., ymax=X97.5.), alpha=0.3) +
theme_bw()
dev.off()
################################################################################
# 12. GRAIN-DEPENDENT ENVIRONMENTAL PREDICTORS
################################################################################
data.frame(all.varnames.REALM)
data.frame(all.varnames.SMOOTH)
# indices of variable coefficients - model REALM
pure.id.REALM <- 8:16
area.id.REALM <- 38:46
# coefficient names
pure.varnames.REALM <- all.varnames.REALM[pure.id.REALM]
pure.coefnames.REALM <- paste("b", pure.varnames.REALM, sep="_")
area.varnames.REALM <- all.varnames.REALM[area.id.REALM]
area.coefnames.REALM <- paste("b", area.varnames.REALM, sep="_")
pure.coefs.REALM <- extract.pars(pure.coefnames.REALM, brm.REALM)
area.coefs.REALM <- extract.pars(area.coefnames.REALM, brm.REALM)
# -----------------
# indices of variable coefficients - model SMOOTH
pure.id.SMOOTH <- 5:13
area.id.SMOOTH <- 14:22
# coefficient names
pure.varnames.SMOOTH <- all.varnames.SMOOTH[pure.id.SMOOTH]
pure.coefnames.SMOOTH <- paste("b", pure.varnames.SMOOTH, sep="_")
area.varnames.SMOOTH <- all.varnames.SMOOTH[area.id.SMOOTH]
area.coefnames.SMOOTH <- paste("b", area.varnames.SMOOTH, sep="_")
pure.coefs.SMOOTH <- extract.pars(pure.coefnames.SMOOTH, brm.SMOOTH)
area.coefs.SMOOTH <- extract.pars(area.coefnames.SMOOTH, brm.SMOOTH)
# -----------------
# function that extracts posterior quantiles of a parameter from a brms model object
get.one.var <- function(i, pure.coefs, area.coefs, varnames, model,
probs=c(0.025, 0.25, 0.5,0.75, 0.975))
{
pure.coef <- pure.coefs[[i]]
area.coef <- area.coefs[[i]]
A <- seq(from=-0.94, to=2.82, by=0.1)
N <- length(pure.coef)
res <- matrix(nrow=length(A), ncol=N)
for(j in 1:N)
{
b.pure <- pure.coef[j]
b.area <- area.coef[j]
res[,j] <- b.pure + b.area*A
}
require(matrixStats)
res <- matrixStats::rowQuantiles(res, probs=probs)
res <- data.frame(Model=model,
variable=rep(varnames[i], times=length(A)),
A, res)
return(res)
}
# ------------------
# function that extracts posterior quantiles of
# multiple parameters from a brms model object
get.vars <- function(pure.coefs, area.coefs, varnames, model,
probs=c(0.025, 0.25, 0.5,0.75, 0.975))
{
res <- list()
for(i in 1:length(varnames))
{
res[[i]] <- get.one.var(i=i,
pure.coefs=pure.coefs,
area.coefs=area.coefs,
varnames= varnames,
model=model)
}
require(plyr)
res <- plyr::ldply(res)
return(res)
}
# ------------------------------------------------------------------------------
# get the quantiles of the posterior distributions using the functions above
REALM.scale.coefs <- get.vars(pure.coefs=pure.coefs.REALM,
area.coefs=area.coefs.REALM,
varnames= pure.varnames.REALM,
model="REALM")
SMOOTH.scale.coefs <- get.vars(pure.coefs=pure.coefs.SMOOTH,
area.coefs=area.coefs.SMOOTH,
varnames= pure.varnames.SMOOTH,
model="SMOOTH")
scale.coefs <- rbind(REALM.scale.coefs, SMOOTH.scale.coefs)
scale.coefs$variable <- as.character(scale.coefs$variable)
# ------------------------------------------------------------------------------
# use better names for scale coefficients
scale.coefs[scale.coefs$variable=="Tree_dens",'variable'] <- "Tree density"
scale.coefs[scale.coefs$variable=="min_DBH",'variable'] <- "Minimum DBH"
scale.coefs[scale.coefs$variable=="ANN_T",'variable'] <- "Annual T"
scale.coefs[scale.coefs$variable=="ISO_T",'variable'] <- "Isothermality"
scale.coefs[scale.coefs$variable=="MIN_P",'variable'] <- "Minimum P"
scale.coefs[scale.coefs$variable=="P_SEAS",'variable'] <- "P Seasonality"
scale.coefs[scale.coefs$variable=="ALT_DIF",'variable'] <- "Elevation span"
scale.coefs[scale.coefs$variable=="ISLAND",'variable'] <- "Island"
scale.coefs$variable <- factor(scale.coefs$variable,
levels=c("Island", "Elevation span", "GPP",
"P Seasonality", "Minimum P",
"Annual T", "Isothermality",
"Tree density", "Minimum DBH") )
# ------------------------------------------------------------------------------
# plot the coefficients
ticks <- data.frame (t = c(-2, 0, 2, 4, 6), l = c(-2,0,2,4, 6))
coef.plot <- ggplot(scale.coefs, aes(x=log10(exp(A*A.sd + A.mean)), y=X50.)) +
geom_ribbon(aes(ymin=X2.5., ymax=X97.5., fill=Model), alpha=0.3) +
#geom_ribbon(aes(ymin=X25., ymax=X75., fill=NA), alpha=0.3) +
geom_line(aes(colour=Model), size=1) +
geom_line(aes(x=log10(exp(A*A.sd + A.mean)), y=X25., colour=Model),
linetype="dashed") +
geom_line(aes(x=log10(exp(A*A.sd + A.mean)), y=X75., colour=Model),
linetype="dashed") +
facet_grid(.~variable) +
geom_hline(yintercept=0, colour="darkgrey") +
xlab(expression(log[10] ~ "Area" ~ (km^2))) +
ylab("Standardized coefficient") +
scale_colour_brewer(palette = "Set1") +
scale_fill_brewer(palette = "Set1") +
scale_x_continuous(breaks=c(ticks$t),
labels=c(ticks$l),
minor_breaks = NULL) +
theme_bw() +
theme(legend.position="right")
coef.plot
# save to a file
png("../Figures/Fig_4_envir_effects.png", width=2200, height=400, res=200)
coef.plot
dev.off()
# save to a file
pdf("../Figures/Fig_4_envir_effects.pdf", width=11, height=2)
coef.plot
dev.off()
################################################################################
# 13. PAIRPLOTS SHOWING COLLINEARITY BETWEEN THE PREDICTORS
################################################################################
for.pairs <- dplyr::select(DAT, Tree_dens, min_DBH, GPP, ANN_T, ISO_T,
MIN_P, P_SEAS, ALT_DIF, ISLAND, REALM, DAT_TYPE)
for.pairs$ISLAND <- as.factor(for.pairs$ISLAND)
p <- ggpairs(for.pairs, aes(colour=DAT_TYPE)) + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# save to a file
png("../Figures/Fig_S7_pairplot.png", width=1500, height=1700, res=100)
p
dev.off()
################################################################################
# 14. ADDITIONAL RANDOM FOREST ANALYSIS
################################################################################
# This is something that we don't deal with in the paper. I've just calculated
# this analysis to explore the data a little bit. The reason for not including
# this is the expected role of collinearity, which may not be sufficiently
# dealt with by the RandomForest algorithm.
# ------------------------------------------------------------------------------
# fit the random forest models
rf.plot <- randomForest(S ~ REALM + Area_km + Tree_dens + min_DBH +
GPP + ANN_T + ISO_T +
MIN_P + P_SEAS + ALT_DIF + ISLAND,
data=DAT[DAT$DAT_TYPE=="Plot",])
rf.country <- randomForest(S ~ REALM + Area_km + Tree_dens + min_DBH +
GPP + ANN_T + ISO_T +
MIN_P + P_SEAS + ALT_DIF + ISLAND,
data=DAT[DAT$DAT_TYPE=="Country",])
# plot variable importance
par(mfrow=c(1,2))
varImpPlot(rf.plot)
varImpPlot(rf.country)
# prepare data for ggplot variable importance plots
plot.imp <- data.frame(variable=rownames(importance(rf.plot)),
importance=importance(rf.plot),
type = as.factor(c(1,0,0,0,0,0,0,0,0,0,0)))
cntr.imp <- data.frame(variable=rownames(importance(rf.country)),
importance=importance(rf.country),
type = as.factor(c(1,0,0,0,0,0,0,0,0,0,0)))
# variable importance plots
cntr.p <- ggplot(cntr.imp, aes(variable, IncNodePurity)) +
geom_col(aes(fill=type)) +
theme_bw() + xlab("Predictor") + ylab("Importance") + coord_flip() +
labs(title = "A", subtitle = "Country")  +
theme(legend.position="none")
plot.p <- ggplot(plot.imp, aes(variable, IncNodePurity)) +
geom_col(aes(fill=type)) +
theme_bw() + xlab("Predictor") + ylab("Importance") + coord_flip() +
labs(title = "B", subtitle = "Plot") +
theme(legend.position="none")
# save to a file
png("../Figures/random_forest_variable_importance.png", width=1000, height=500, res=150)
grid.arrange(cntr.p, plot.p, ncol=2)
dev.off()
16+6+17+19+25+78+49+97+50
