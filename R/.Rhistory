P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
INSULARITY + INSULARITY:Area_km
SMOOTH.formula <- S ~ s(Lat, Lon, by=DAT_TYPE, bs="sos", k=14) +
poly(Area_km, 3) +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
INSULARITY + INSULARITY:Area_km
gam.REALM <- gam(REALM.formula, data=DAT, family="nb")
summary(gam.REALM)
gam.SMOOTH <- gam(SMOOTH.formula, data = DAT, family="nb")
summary(gam.SMOOTH)
save(gam.SMOOTH, file="../STAN_models/gam_SMOOTH.Rdata")
REALM.formula <- S ~ REALM + poly(Area_km,3):REALM +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
INSULARITY + INSULARITY:Area_km +
ELONGATION + ELONGATION:Area_km
SMOOTH.formula <- S ~ s(Lat, Lon, by=DAT_TYPE, bs="sos", k=14) +
poly(Area_km, 3) +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
INSULARITY + INSULARITY:Area_km +
ELONGATION + ELONGATION:Area_km
gam.REALM <- gam(REALM.formula, data=DAT, family="nb")
summary(gam.REALM)
SMOOTH.formula <- S ~ s(Lat, Lon, by=DAT_TYPE, bs="sos", k=14) +
poly(Area_km, 3) +
Tree_dens + Tree_dens:Area_km +
min_DBH + min_DBH:Area_km +
GPP + GPP:Area_km +
ANN_T + ANN_T:Area_km +
ISO_T + ISO_T:Area_km +
MIN_P + MIN_P:Area_km +
P_SEAS + P_SEAS:Area_km +
ALT_DIF + ALT_DIF:Area_km +
INSULARITY + INSULARITY:Area_km +
ELONGATION + ELONGATION:Area_km
gam.SMOOTH <- gam(SMOOTH.formula, data = DAT, family="nb")
summary(gam.SMOOTH)
save(gam.SMOOTH, file="../STAN_models/gam_SMOOTH.Rdata")
# compare the models using AIC
AIC(gam.NULL, gam.REALM, gam.SMOOTH)
# additionally, fit model with only the intercept (a 'null' model)
gam.NULL <- gam(S~1, data=DAT, family="nb")
# compare the models using AIC
AIC(gam.NULL, gam.REALM, gam.SMOOTH)
################################################################################
# 4. PLOT OBSERVED VS. PREDICTED VALUES
################################################################################
pred.REALM <- data.frame( DAT, pred=predict(gam.REALM, type="response"),
model="Model REALM")
pred.SMOOTH <- data.frame( DAT, pred=predict(gam.SMOOTH, type="response"),
model="Model SMOOTH")
pred <- rbind(pred.REALM, pred.SMOOTH)
obs.glm <- ggplot(pred, aes(log10(S), log10(pred))) +
geom_point(aes(colour=REALM), shape=1) +
xlab("log10 Observed S") + ylab("log10 Predicted S") +
geom_abline(intercept = 0, slope = 1, colour="black") + theme_bw() +
scale_colour_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(0, 4)) + scale_y_continuous(limits = c(0, 4)) +
facet_grid(.~model) +
labs(size = "log10 Area [km]") + labs(colour = "Region") +
guides(colour = guide_legend(override.aes = list(size=4, shape=19), title="Region"))
obs.glm
# export the figure
png("../Figures/Fig_S1_obs_vs_pred.png", width=2000, height=950, res=250)
obs.glm
dev.off()
# width of the correlogram increment [km]
increment = 200
# Residual correlograms for Model REALM -----------------
res.REALM <- data.frame(Lat=DAT$Lat, Lon=DAT$Lon, S=DAT$S,
DAT_TYPE=DAT$DAT_TYPE,
resid=residuals(gam.REALM))
res.REALM.cntr <- res.REALM[res.REALM$DAT_TYPE=="Country",]
res.REALM.plot <- res.REALM[res.REALM$DAT_TYPE=="Plot",]
cor.REALM.cntr <- ncf::correlog(x=res.REALM.cntr$Lat, y=res.REALM.cntr$Lon,
z=res.REALM.cntr$resid,
latlon=TRUE, resamp=1, increment=increment)
cor.REALM.plot <- ncf::correlog(x=res.REALM.plot$Lat, y=res.REALM.plot$Lon,
z=res.REALM.plot$resid,
latlon=TRUE, resamp=1, increment=increment)
# Residual correlograms for Model SMOOTH -----------------
res.SMOOTH <- data.frame(Lat=DAT$Lat, Lon=DAT$Lon, S=DAT$S,
DAT_TYPE=DAT$DAT_TYPE,
resid=residuals(gam.SMOOTH))
res.SMOOTH.cntr <- res.SMOOTH[res.SMOOTH$DAT_TYPE=="Country",]
res.SMOOTH.plot <- res.SMOOTH[res.SMOOTH$DAT_TYPE=="Plot",]
cor.SMOOTH.cntr <- ncf::correlog(x=res.SMOOTH.cntr$Lat, y=res.SMOOTH.cntr$Lon,
z=res.SMOOTH.cntr$resid,
latlon=TRUE, resamp=1, increment=increment)
cor.SMOOTH.plot <- ncf::correlog(x=res.SMOOTH.plot$Lat, y=res.SMOOTH.plot$Lon,
z=res.SMOOTH.plot$resid,
latlon=TRUE, resamp=1, increment=increment)
# Correlograms for S
cor.S.cntr <- ncf::correlog(x=res.SMOOTH.cntr$Lat, y=res.SMOOTH.cntr$Lon,
z=res.SMOOTH.cntr$S,
latlon=TRUE, resamp=1, increment=increment)
cor.S.plot <- ncf::correlog(x=res.SMOOTH.plot$Lat, y=res.SMOOTH.plot$Lon,
z=res.SMOOTH.plot$S,
latlon=TRUE, resamp=1, increment=increment)
# extract the correlograms for further plotting
N <- length(cor.REALM.plot$mean.of.class)
RP <- data.frame(Dist=cor.REALM.plot$mean.of.class,
Cor=cor.REALM.plot$correlation,
Scale=rep("Plot"),
Variable=rep("REALM residuals"))
RC <- data.frame(Dist=cor.REALM.cntr$mean.of.class,
Cor=cor.REALM.cntr$correlation,
Scale=rep("Country"),
Variable=rep("REALM residuals"))
SP <- data.frame(Dist=cor.SMOOTH.plot$mean.of.class,
Cor=cor.SMOOTH.plot$correlation,
Scale=rep("Plot"),
Variable=rep("SMOOTH residuals"))
SC <- data.frame(Dist=cor.SMOOTH.cntr$mean.of.class,
Cor=cor.SMOOTH.cntr$correlation,
Scale=rep("Country"),
Variable=rep("SMOOTH residuals"))
RIC <- data.frame(Dist=cor.S.cntr$mean.of.class,
Cor=cor.S.cntr$correlation,
Scale=rep("Country"),
Variable=rep("Species richness S"))
RIP <- data.frame(Dist=cor.S.plot$mean.of.class,
Cor=cor.S.plot$correlation,
Scale=rep("Plot"),
Variable=rep("Species richness S"))
cor.data <- rbind(RP, RC, SP, SC, RIP, RIC)
# plot the correlograms
png("../Figures/Fig_S4_correlograms.png", width=2000, height=900, res=250)
ggplot(cor.data, aes(x=Dist, y=Cor)) +
geom_point(aes(colour=Variable, shape=Variable)) +
geom_line(aes(colour=Variable)) +
geom_hline(yintercept = 0, colour="darkgrey") +
xlim(c(0, 3000)) + ylim(c(-0.2,0.5)) +
scale_colour_brewer(palette="Set1") +
facet_grid(.~Scale) +
xlab("Distance [km]") + ylab("Moran's I") +
theme_bw()
dev.off()
################################################################################
# 6. PLOT MAPS
################################################################################
# extract the smooth GAM surfaces representing history
prd <- predict.gam(gam.SMOOTH, type="terms")
smooth.country <- prd[,"s(Lat,Lon):DAT_TYPECountry"]
smooth.plot <- prd[,"s(Lat,Lon):DAT_TYPEPlot"]
PRED <- data.frame(DAT, smooth.country, smooth.plot)
# extract predicted species richness
S.pred <- predict.gam(gam.SMOOTH, type="response")
PRED <- data.frame(PRED, S.pred)
# reproject geogrpahic coordinates of centroids to a Mollweide projection
latlon <- SpatialPoints(data.frame(PRED$Lon, PRED$Lat), CRS(WGS84))
xy <- data.frame(coordinates(spTransform(latlon, CRSobj = CRS(MOLLWEIDE))))
names(xy) <- c("X", "Y")
PRED <- data.frame(PRED, xy)
# select prediction data for countries
PRED.CNTRS <- PRED[PRED$DAT_TYPE=="Country",]
# global mainlands (not divided by country boundaries)
MAINL <- readOGR(dsn = "../Data/COUNTRIES", layer = "GSHHS_i_L1_simple")
MAINL <- spTransform(MAINL, CRSobj = CRS(MOLLWEIDE))
MAINL <- tidy(MAINL, region="id")
# equator, tropics, and polar circles
LINES <- readOGR(dsn = "../Data/COUNTRIES", layer = "ne_110m_geographic_lines")
LINES <- spTransform(LINES, CRSobj = CRS(MOLLWEIDE))
LINES <- tidy(LINES, region="name")
# load the country shapefile
CNTRS <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES_with_environment")
CNTRS@data <- dplyr::select(CNTRS@data, NAME)
# remove the big countries
CNTRS <- CNTRS[(CNTRS$NAME %in% c("China", "United States", "Brazil")) == FALSE,]
# reproject the countries
CNTRS <- spTransform(CNTRS, CRSobj = CRS(MOLLWEIDE))
PRED.CNTRS <- merge(CNTRS, PRED.CNTRS, by.x="NAME", by.y="Loc_ID")
PRED.CNTRS[PRED.CNTRS$NAME == "Alaska","REALM"] <- "Nearctic"
PRED.CNTRS[PRED.CNTRS$NAME == "Alaska","ISLAND"] <- 0
# create the norhtern-southern hemisphere identifier
PRED.CNTRS@data <- data.frame(PRED.CNTRS@data, Hemisphere=rep("Palearctic & Nearctic",
times=nrow(PRED.CNTRS@data)))
is.Tropics <- (PRED.CNTRS@data$REALM %in% c("Western Palearctic","Eastern Palearctic","Nearctic")) == FALSE
a <- PRED.CNTRS@data
a$Hemisphere <- as.character(a$Hemisphere)
a$Hemisphere[is.Tropics] <- "Tropics"
PRED.CNTRS@data <- a
# DATA FOR PLOTS ---------------------------------------------------------------
PRED.PLOTS <- PRED[PRED$DAT_TYPE=="Plot",]
# prepare the polygons for GGPLOT2 ---------------
C.fort <- tidy(PRED.CNTRS, region="NAME")
C.fort <- merge(C.fort, PRED.CNTRS@data, by.x="id", by.y="NAME")
# BLANK THEME FOR GGPLOT2
blank.theme <- theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
blank.theme <- theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
legend.position=c(0.6, 0.05),
legend.direction = "horizontal",
legend.title = element_blank(),
#legend.title.align = 0,
panel.background=element_blank(),
panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
# ------------------------------------------------------------------------------
# SMOOTHER MAPS
g.cntr <- ggplot(C.fort, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(aes(fill=smooth.country), colour="black", size=.2) +
scale_fill_distiller(palette = "Spectral",
limits=c(-2, 2),
name="Region\neffect") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
xlab("") + ylab("") +
ggtitle("A") +
theme_minimal() + blank.theme
g.plot <- ggplot(MAINL, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(fill="white", colour="black", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL, colour=smooth.plot)) +
scale_colour_distiller(palette = "Spectral",
limits=c(-2, 2),
name="Region\neffect") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
xlab("") + ylab("") +
ggtitle("B") +
theme_minimal() + blank.theme
g.plot.rescaled <- ggplot(MAINL, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(fill="white", colour="black", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL, colour=smooth.plot)) +
scale_colour_distiller(palette = "Spectral",
#limits=c(-2, 2),
name="Region\neffect") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
xlab("") + ylab("") +
ggtitle("C") + labs(subtitle = "Color scale differs from A and B") +
theme_minimal() + blank.theme
# save to a file
png("../Figures/smooth_map.png", width=2000, height=2000, res=250)
grid.arrange(g.cntr, g.plot, ncol=1, nrow=2)
dev.off()
# ------------------------------------------------------------------------------
# PREDICTED RICHNESS MAPS
s.pred.cntr <- ggplot(C.fort, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(aes(fill=S.pred), colour="black", size=.2) +
scale_fill_distiller(palette = "Spectral", name="Predicted S",
trans="log10") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
ggtitle("A") + theme_minimal() +
xlab("") + ylab("") + blank.theme
s.pred.plot <- ggplot(MAINL, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(fill="white", colour="black", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL, colour=S.pred)) +
scale_colour_distiller(palette = "Spectral", name="Predicted S",
trans="log10") +
scale_x_continuous(limits = c(-13000000, 16000000)) +
ggtitle("B") + theme_minimal() +
xlab("") + ylab("") + blank.theme
# ------------------------------------------------------------------------------
# RAW RICHNESS MAPS
s.cntr <- ggplot(C.fort, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(aes(fill=S), colour="black", size=.2) +
scale_fill_distiller(palette = "Spectral", name="S",
trans="log10", limits=c(1,6500)) +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
ggtitle("A") + theme_minimal() +
# labs(subtitle = expression(S[country] ~ "(richness at the country grain)")) +
xlab("") + ylab("") + blank.theme
s.plot <- ggplot(MAINL, aes(long, lat, group=group)) +
geom_polygon(data=LINES,  aes(long, lat, group=group),
colour="darkgrey", size=0.2) +
geom_polygon(fill="lightgrey", colour="black", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL, colour=S), size=1) +
#geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), size=1, colour="black",
#           shape =1 , size=.2) +
scale_colour_distiller(palette = "Spectral", name="S",
trans="log10", limits=c(1,6500)) +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
ggtitle("B") + theme_minimal() +
#labs(subtitle = expression(S[plot] ~ "(richness at the plot grain)")) +
xlab("") + ylab("") + blank.theme
tiff("../Figures/Fig_1_richness_map.tif", width=2000, height=2100, res=350,
compression = "lzw")
grid.arrange(s.cntr, s.plot, ncol=1, nrow=2)
dev.off()
# ------------------------------------------------------------------------------
# BIOGEOGRAPHIC REALMS
blank.theme <- theme(axis.line=element_blank(),axis.text.x=element_blank(),
axis.text.y=element_blank(),axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),plot.background=element_blank())
# save to a file
png("../Figures/Fig_S9_realms_map.png", width=2300, height=1000, res=200)
realm.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=3, colour="black") +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
# save to a file
png("../Figures/realms_map.png", width=2300, height=1000, res=200)
realm.plot <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
geom_point(data=PRED.PLOTS, aes(x=X, y=Y, group=NULL), shape=1, colour="black") +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
# save to a file
png("../Figures/realms_map_small.png", width=2400, height=1000, res=400)
realm.plot.small <- ggplot(C.fort[is.na(C.fort$REALM) == FALSE,], aes(long, lat, group=group)) +
geom_polygon(aes(fill=REALM), colour="darkgray", size=.2) +
scale_fill_brewer(palette = "Dark2", name="Realm") +
scale_x_continuous(limits = c(-12000000, 16000000)) +
scale_y_continuous(limits = c(-6.4e+06, 8.8e+06)) +
xlab("") + ylab("") + theme_minimal() + blank.theme +
theme(legend.position="right") +
guides(fill=guide_legend(title=NULL))
realm.plot
dev.off()
################################################################################
# 7. FIT THE MODELS IN STAN, using 'brms' function 'brm'
################################################################################
# Beware, this will take 30 min to run (approximately) on a 2GHz 2-core laptop.
# YOU CAN SKIP THIS AND LOAD THE FITTED MODELS IN STEP 8!!!
brm.SMOOTH <- brm(SMOOTH.formula, family="negbinomial", data=DAT,
cores=3,
seed=12355,
chains=3, iter=3000, warmup=1000, thin=10)
# clean the workspace and load the libraries
source("0_libraries_functions_settings.r")
# ------------------------------------------------------------------------------
# read the raw PLOT data
PLOTS <- read.csv("../Data/PLOTS/PLOTS_all_data_raw_tab_delimited.txt",
sep="\t", header=TRUE)
# convert the coordinates to 'sp' object
plots <- SpatialPointsDataFrame(coords=data.frame(PLOTS$Lon, PLOTS$Lat),
data = PLOTS,
proj4string=CRS(WGS84))
# read the COUNTRY data (as a shapefile with data in the attribute table)
COUNTR.shp <- readOGR(dsn="../Data/COUNTRIES", layer = "COUNTRIES")
COUNTR.shp <- spTransform(x = COUNTR.shp, CRSobj = WGS84)
## OLD APPROACH WHERE TRUE ISLANDS AND SHELF ILANDS WERE ALL LUMPED TOGETHER
## extract plots
MAINL <- readOGR(dsn = "/media/pk33loci/Elements/GIS_data/Boundaries/GLOBAL_SHORELINE",
layer = "main_landmasses")
MAINL <- spTransform(MAINL,  CRSobj = WGS84)
MAINL <- readOGR(dsn = "/media/pk33loci/Elements/GIS_data/Boundaries/GLOBAL_SHORELINE",
layer = "main_landmasses")
MAINL <- spTransform(MAINL,  CRSobj = WGS84)
CONTS <- over(x=plots, y=MAINL)
is.island <- is.na(CONTS$continent == "<NA>")*1
plots@data$ISLAND <- is.island
plot(plots, col=plots@data$ISLAND+1); plot(MAINL, add=T)
## extract countries
CONTS <- over(SpatialPoints(coordinates(COUNTR.shp), proj4string=CRS(WGS84)), y=MAINL)
COUNTR.shp@data$ISLAND <- is.na(CONTS$continent == "<NA>")*1
X11()
plot(plots, col=plots@data$ISLAND+1); plot(MAINL, add=T)
################################################################################
# clean the workspace and load the libraries
source("0_libraries_functions_settings.r")
# ------------------------------------------------------------------------------
# load the mainland layer (i.e. everyting except for islands)
MAINL <- readOGR(dsn = "/media/pk33loci/Elements/GIS_data/Boundaries/GLOBAL_SHORELINE",
layer = "main_landmasses")
proj4string(MAINL) <- WGS84
# ------------------------------------------------------------------------------
# LOAD THE HEXAGONAL GRID THAT WILL BE USED FOR PREDICTIONS
grid5 <- readOGR(dsn="../Data/GRIDS", layer = "hex5")
grid5 <- spTransform(grid5, CRSobj = WGS84)
gr.coords <- data.frame(coordinates(grid5))
names(gr.coords) <- c("Lon", "Lat")
grid5@data <- data.frame(grid5@data, gr.coords)
# read a global 10X10 km raster on annual temperature (will be used to create a grid)
# and convert it to a global raster of 10x10km cells with area of each cell
RAST <- raster("../Data/GRIDS/ANN_T10.tif")
RAST[is.na(RAST) == FALSE] <- 1
RAST.area <- raster::area(RAST)
RAST.area <- RAST.area * RAST
RAST.area[is.na(RAST.area)] <- 0
plot(RAST.area)
# the area of each hexagonal cell in km^2
grid5.totarea <- gArea(spTransform(grid5, CRSobj = LAMBERT), byid=TRUE) / 1000000
# calculate the area of land in km^2
grid5.area <- raster::extract(x=RAST.area, y=grid5, fun=sum)
# calculate area of mainland (non-island) in km
ML.rast <- rasterize(x = MAINL, y=RAST)
ML.rast[is.na(ML.rast) == FALSE] <- 1
ML.rast.area <- raster::area(ML.rast)
ML.rast.area <- ML.rast.area * ML.rast
ML.rast.area[is.na(ML.rast.area)] <- 0
plot(ML.rast.area)
grid5.ML.area <- raster::extract(x=ML.rast.area, y=grid5, fun=sum)
ISLAND <- raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/ISLAND_clean.tif")
ALL.LAND <- raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/LAND_clean.tif")
MAINLAND <- ALL.LAND - ISLAND
X11()
plot(MAINLAND)
is.island.plots <- raster::extract(x = ISLAND, y = pts)
pt.coords <- read.csv(file="../Data/GRIDS/Fine_points.csv")
pts <- SpatialPointsDataFrame(pt.coords,
proj4string=CRS(WGS84),
data=data.frame(ptID = paste("pt", 1:nrow(pt.coords), sep="")))
pts@data <- data.frame(pts@data, pt.coords)
is.island.plots <- raster::extract(x = ISLAND, y = pts)
is.island.plots
is.mainland.plots <- raster::extract(x = MAINLAND, y = plots)
is.island.plots <- ifelse(is.mainland.plots == 1, "mainland", "island")
is.mainland.plots <- raster::extract(x = MAINLAND, y = pts)
is.island.plots <- ifelse(is.mainland.plots == 1, "mainland", "island")
plots@data$INSULARITY <- is.island.plots
pts@data$INSULARITY <- is.island.plots
spplot(pts, zcol="INSULARITY")
plot(pts)
plot(pts, col="INSULARITY")
plot(pts, col=pts$INSULARITY)
plot(pts, col=as.factor(pts$INSULARITY))
is.island.plots <- raster::extract(x = ISLAND, y = pts)
is.island.plots <- ifelse(is.mainland.plots == 1, "island", "mainland")
plot(pts, col=as.factor(pts$INSULARITY))
pts@data$INSULARITY <- is.island.plots
plot(pts, col=as.factor(pts$INSULARITY))
plot(MAINLAND)
plot(MAINLAND + ISLAND)
plot(ISLAND)
is.island.plots <- raster::extract(x = ISLAND, y = pts)
is.island.plots <- ifelse(is.island.plots == 1, "island", "mainland")
pts@data$INSULARITY <- is.island.plots
plot(ISLAND)
plot(pts, col=as.factor(pts$INSULARITY))
is.mainl.hex <- raster::extract(x = MAINLAND, y = grid5, fun = max)
is.isl.hex <- as.vector((is.mainl.hex == 0) * 1)
grid5@data$INSULARITY <- is.isl.hex
spplot(grid5, zcol="ISLAND")
## OLD APPROACH WHERE TRUE ISLANDS AND SHELF ILANDS WERE ALL LUMPED TOGETHER
MAINL <- readOGR(dsn = "/media/pk33loci/Elements/GIS_data/Boundaries/GLOBAL_SHORELINE",
layer = "main_landmasses")
MAINL <- spTransform(MAINL,  CRSobj = WGS84)
# extract points for predictions
CONTS <- over(x=pts, y=MAINL)
is.island <- is.na(CONTS$continent == "<NA>")*1
pts@data$ISLAND <- is.island
plot(pts, col=pts@data$ISLAND+1); plot(MAINL, add=T)
# calculate the ISLAND status of the hexagonal cells
hexISL <- 1 - grid5$MainlArea/grid5$LandArea
hexISL <- ifelse(hexISL > 0.9, 1, 0)
grid5@data <- data.frame(grid5@data, ISLAND=hexISL)
## OLD APPROACH WHERE TRUE ISLANDS AND SHELF ILANDS WERE ALL LUMPED TOGETHER
MAINL <- readOGR(dsn = "/media/pk33loci/Elements/GIS_data/Boundaries/GLOBAL_SHORELINE",
layer = "main_landmasses")
MAINL <- spTransform(MAINL,  CRSobj = WGS84)
# extract points for predictions
CONTS <- over(x=pts, y=MAINL)
is.island <- is.na(CONTS$continent == "<NA>")*1
pts@data$ISLAND <- is.island
plot(pts, col=pts@data$ISLAND+1); plot(MAINL, add=T)
# calculate the ISLAND status of the hexagonal cells
hexISL <- 1 - grid5$MainlArea/grid5$LandArea
hexISL <- ifelse(hexISL > 0.9, 1, 0)
grid5@data <- data.frame(grid5@data, ISLAND=hexISL)
nrow(hexISL)
# calculate the ISLAND status of the hexagonal cells
hexISL <- 1 - grid5$MainlArea/grid5$LandArea
hexISL
grid5$MainlArea
grid5$LandArea
