b.area <- area.coef[j]
res[,j] <- b.pure + b.area*A
}
require(matrixStats)
res <- matrixStats::rowQuantiles(res, probs=probs)
res <- data.frame(Model=model,
variable=rep(varnames[i], times=length(A)),
A, res)
return(res)
}
# ------------------
# function that extracts posterior quantiles of
# multiple parameters from a brms model object
get.vars <- function(pure.coefs, area.coefs, varnames, model,
probs=c(0.025, 0.25, 0.5,0.75, 0.975))
{
res <- list()
for(i in 1:length(varnames))
{
res[[i]] <- get.one.var(i=i,
pure.coefs=pure.coefs,
area.coefs=area.coefs,
varnames= varnames,
model=model)
}
require(plyr)
res <- plyr::ldply(res)
return(res)
}
# ------------------------------------------------------------------------------
# get the quantiles of the posterior distributions using the functions above
REALM.scale.coefs <- get.vars(pure.coefs=pure.coefs.REALM,
area.coefs=area.coefs.REALM,
varnames= pure.varnames.REALM,
model="REALM")
SMOOTH.scale.coefs <- get.vars(pure.coefs=pure.coefs.SMOOTH,
area.coefs=area.coefs.SMOOTH,
varnames= pure.varnames.SMOOTH,
model="SMOOTH")
scale.coefs <- rbind(REALM.scale.coefs, SMOOTH.scale.coefs)
scale.coefs$variable <- as.character(scale.coefs$variable)
# ------------------------------------------------------------------------------
# use better names for scale coefficients
scale.coefs[scale.coefs$variable=="Tree_dens",'variable'] <- "Tree density"
scale.coefs[scale.coefs$variable=="min_DBH",'variable'] <- "Minimum DBH"
scale.coefs[scale.coefs$variable=="ANN_T",'variable'] <- "Annual T"
scale.coefs[scale.coefs$variable=="ISO_T",'variable'] <- "Isothermality"
scale.coefs[scale.coefs$variable=="MIN_P",'variable'] <- "Minimum P"
scale.coefs[scale.coefs$variable=="P_SEAS",'variable'] <- "P Seasonality"
scale.coefs[scale.coefs$variable=="ALT_DIF",'variable'] <- "Elevation span"
scale.coefs[scale.coefs$variable=="ISLAND",'variable'] <- "Island"
scale.coefs$variable <- factor(scale.coefs$variable,
levels=c("Island", "Elevation span", "GPP",
"P Seasonality", "Minimum P",
"Annual T", "Isothermality",
"Tree density", "Minimum DBH") )
# ------------------------------------------------------------------------------
# plot the coefficients
ticks <- data.frame (t = c(-2, 0, 2, 4, 6), l = c(-2,0,2,4, 6))
coef.plot <- ggplot(scale.coefs, aes(x=log10(exp(A*A.sd + A.mean)), y=X50.)) +
geom_ribbon(aes(ymin=X2.5., ymax=X97.5., fill=Model), alpha=0.3) +
#geom_ribbon(aes(ymin=X25., ymax=X75., fill=NA), alpha=0.3) +
geom_line(aes(colour=Model), size=1) +
geom_line(aes(x=log10(exp(A*A.sd + A.mean)), y=X25., colour=Model),
linetype="dashed") +
geom_line(aes(x=log10(exp(A*A.sd + A.mean)), y=X75., colour=Model),
linetype="dashed") +
facet_grid(.~variable) +
geom_hline(yintercept=0, colour="darkgrey") +
xlab(expression(log[10] ~ "Area" ~ (km^2))) +
ylab("Standardized coefficient") +
scale_colour_brewer(palette = "Set1") +
scale_fill_brewer(palette = "Set1") +
scale_x_continuous(breaks=c(ticks$t),
labels=c(ticks$l),
minor_breaks = NULL) +
theme_bw() +
theme(legend.position="right")
coef.plot
# save to a file
png("../Figures/Fig_4_envir_effects.png", width=2200, height=400, res=200)
coef.plot
dev.off()
# save to a file
pdf("../Figures/Fig_4_envir_effects.pdf", width=11, height=2)
coef.plot
dev.off()
################################################################################
# 13. PAIRPLOTS SHOWING COLLINEARITY BETWEEN THE PREDICTORS
################################################################################
for.pairs <- dplyr::select(DAT, Tree_dens, min_DBH, GPP, ANN_T, ISO_T,
MIN_P, P_SEAS, ALT_DIF, ISLAND, REALM, DAT_TYPE)
for.pairs$ISLAND <- as.factor(for.pairs$ISLAND)
p <- ggpairs(for.pairs, aes(colour=DAT_TYPE)) + theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
# save to a file
png("../Figures/Fig_S7_pairplot.png", width=1500, height=1700, res=100)
p
dev.off()
################################################################################
# 14. ADDITIONAL RANDOM FOREST ANALYSIS
################################################################################
# This is something that we don't deal with in the paper. I've just calculated
# this analysis to explore the data a little bit. The reason for not including
# this is the expected role of collinearity, which may not be sufficiently
# dealt with by the RandomForest algorithm.
# ------------------------------------------------------------------------------
# fit the random forest models
rf.plot <- randomForest(S ~ REALM + Area_km + Tree_dens + min_DBH +
GPP + ANN_T + ISO_T +
MIN_P + P_SEAS + ALT_DIF + ISLAND,
data=DAT[DAT$DAT_TYPE=="Plot",])
rf.country <- randomForest(S ~ REALM + Area_km + Tree_dens + min_DBH +
GPP + ANN_T + ISO_T +
MIN_P + P_SEAS + ALT_DIF + ISLAND,
data=DAT[DAT$DAT_TYPE=="Country",])
# plot variable importance
par(mfrow=c(1,2))
varImpPlot(rf.plot)
varImpPlot(rf.country)
# prepare data for ggplot variable importance plots
plot.imp <- data.frame(variable=rownames(importance(rf.plot)),
importance=importance(rf.plot),
type = as.factor(c(1,0,0,0,0,0,0,0,0,0,0)))
cntr.imp <- data.frame(variable=rownames(importance(rf.country)),
importance=importance(rf.country),
type = as.factor(c(1,0,0,0,0,0,0,0,0,0,0)))
# variable importance plots
cntr.p <- ggplot(cntr.imp, aes(variable, IncNodePurity)) +
geom_col(aes(fill=type)) +
theme_bw() + xlab("Predictor") + ylab("Importance") + coord_flip() +
labs(title = "A", subtitle = "Country")  +
theme(legend.position="none")
plot.p <- ggplot(plot.imp, aes(variable, IncNodePurity)) +
geom_col(aes(fill=type)) +
theme_bw() + xlab("Predictor") + ylab("Importance") + coord_flip() +
labs(title = "B", subtitle = "Plot") +
theme(legend.position="none")
# save to a file
png("../Figures/random_forest_variable_importance.png", width=1000, height=500, res=150)
grid.arrange(cntr.p, plot.p, ncol=2)
dev.off()
16+6+17+19+25+78+49+97+50
elongation.sample <- function(pol, draw = FALSE)
{
require(sp)
LAT = coordinates(pol)[1,2]
LON = coordinates(pol)[1,1]
AED <- paste("+proj=aeqd +lat_0=",
LAT,
" +lon_0=",
LON,
" +x_0=100000 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs",
sep = "")
pol <- spTransform(pol, CRSobj = CRS(AED))
# convert polygon to lines
lin <- as(pol, "SpatialLines")
# sample points around the line at regular intervals
pts <- spsample(lin, n = 100, type = "regular")
# distance matrix for the points
dst <- dist(coordinates(pts))
# Principal Coordinates Analysis of the distance matrix
eigs <- cmdscale(dst, k = 2, eig = TRUE)$eig[1:2]
# Ratio of the first and the second eigenvalue (squared)
elong <- sqrt(eigs[1]) / sqrt(eigs[2])
if(draw)
{
plot(pol, main  = paste(pol@data$NAME[1], ", ", round(elong, 2 ), sep = ""), col="grey")
points(pts, col="red")
}
return(elong)
}
# ------------------------------------------------------------------------------
# Function that takes a polygon (must be in WGS84 Lat Long system),
# and calculates its elongation based on the ratio of the first two
# eigenvalues of a Principal Coordinate Analysis of an ***ellipsoid hull***
# fitted around the borders.
# Arguments: pol - the polygon
#            draw - should the polygon be plotted?
elongation.ellipse <- function(pol, draw = FALSE)
{
require(sp)
require(cluster) # for the ellipsoid hull funciton
require(car) # another one for ellipses
LAT = coordinates(pol)[1,2]
LON = coordinates(pol)[1,1]
AED <- paste("+proj=aeqd +lat_0=",
LAT,
" +lon_0=",
LON,
" +x_0=100000 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs",
sep = "")
pol <- spTransform(pol, CRSobj = CRS(AED))
# convert polygon to lines
lin <- as(pol, "SpatialLines")
# convert lines to points
pts <- as(lin, "SpatialPoints")
# fit the ellipsoid hull to the points
elps <- ellipsoidhull(pts@coords)
# convert elps to an actual set of points
pts <- ellipse(center = elps$loc, shape = elps$cov, radius = sqrt(elps$d2),
segments = 100, draw = FALSE, add=FALSE)
# distance matrix for the points
dst <- dist(pts)
# Principal Coordinates Analysis of the distance matrix
eigs <- cmdscale(dst, k = 2, eig = TRUE)$eig[1:2]
# Ratio of the first and the second eigenvalue (squared)
elong <- sqrt(eigs[1]) / sqrt(eigs[2])
if(draw)
{
plot(pol, main  = paste(pol@data$NAME[1], ", ", round(elong, 2 ), sep = ""), col="grey")
lines(pts, col="red")
}
return(elong)
}
test.on.all.polygons = FALSE
CTR <- readOGR(dsn = "..Data/COUNTRIES", layer = "COUNTRIES")
################################################################################
# Author: Petr Keil
# Email: pkeil@seznam.cz
# Date: Dec 7 2017
################################################################################
# Description: Here the workspace is cleaned, all the necessary libraries are
# loaded, and the geographic projections are defined.
# ------------------------------------------------------------------------------
# clean everything
rm(list=ls())
# ------------------------------------------------------------------------------
# LIBRARIES
# statistical modelling
library(dummies)
library(MASS)
library(rstan)
library(mcmcplots)
library(brms)
library(randomForest)
library(ncf)
library(mgcv)
library(broom)
library(matrixStats)
# tables
library(xtable)
library(R2HTML)
# GIS libraries
library(rgdal)
library(raster)
library(rgeos)
library(sp)
library(maps)
# data manipulation libraries
library(dplyr)
library(plyr)
library(reshape)
# plotting libraries
library(RColorBrewer)
library(latticeExtra)
library(gridExtra)
library(ggplot2)
library(colorRamps)
library(GGally)
library(ggthemes)
# eigenvalues of a Principal Coordinate Analysis of its ***borders***.
# Arguments: pol - the polygon
#            draw - should the polygon be plotted?
elongation.sample <- function(pol, draw = FALSE)
{
LAT = coordinates(pol)[1,2]
LON = coordinates(pol)[1,1]
AED <- paste("+proj=aeqd +lat_0=",
LAT,
" +lon_0=",
LON,
" +x_0=100000 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs",
sep = "")
pol <- spTransform(pol, CRSobj = CRS(AED))
# convert polygon to lines
lin <- as(pol, "SpatialLines")
# sample points around the line at regular intervals
pts <- spsample(lin, n = 100, type = "regular")
# distance matrix for the points
dst <- dist(coordinates(pts))
# Principal Coordinates Analysis of the distance matrix
eigs <- cmdscale(dst, k = 2, eig = TRUE)$eig[1:2]
# Ratio of the first and the second eigenvalue (squared)
elong <- sqrt(eigs[1]) / sqrt(eigs[2])
if(draw)
{
plot(pol, main  = paste(pol@data$NAME[1], ", ", round(elong, 2 ), sep = ""), col="grey")
points(pts, col="red")
}
return(elong)
}
# ------------------------------------------------------------------------------
# Function that takes a polygon (must be in WGS84 Lat Long system),
# and calculates its elongation based on the ratio of the first two
# eigenvalues of a Principal Coordinate Analysis of an ***ellipsoid hull***
# fitted around the borders.
# Arguments: pol - the polygon
#            draw - should the polygon be plotted?
elongation.ellipse <- function(pol, draw = FALSE)
{
LAT = coordinates(pol)[1,2]
LON = coordinates(pol)[1,1]
AED <- paste("+proj=aeqd +lat_0=",
LAT,
" +lon_0=",
LON,
" +x_0=100000 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs",
sep = "")
pol <- spTransform(pol, CRSobj = CRS(AED))
# convert polygon to lines
lin <- as(pol, "SpatialLines")
# convert lines to points
pts <- as(lin, "SpatialPoints")
# fit the ellipsoid hull to the points
elps <- ellipsoidhull(pts@coords)
# convert elps to an actual set of points
pts <- ellipse(center = elps$loc, shape = elps$cov, radius = sqrt(elps$d2),
segments = 100, draw = FALSE, add=FALSE)
# distance matrix for the points
dst <- dist(pts)
# Principal Coordinates Analysis of the distance matrix
eigs <- cmdscale(dst, k = 2, eig = TRUE)$eig[1:2]
# Ratio of the first and the second eigenvalue (squared)
elong <- sqrt(eigs[1]) / sqrt(eigs[2])
if(draw)
{
plot(pol, main  = paste(pol@data$NAME[1], ", ", round(elong, 2 ), sep = ""), col="grey")
lines(pts, col="red")
}
return(elong)
}
#-------------------------------------------------------------------------------
# Should the plots showing the elongation metric for each polygon be plotted?
test.on.all.polygons = FALSE
if(test.on.all.polygons)
{
CTR <- readOGR(dsn = "..Data/COUNTRIES", layer = "COUNTRIES")
# plot a huge figure with all the polygons and their elongation value
pdf("../Figures/Elongations.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
pol <- CTR[i,]
elong <- elongation.sample(pol, draw = TRUE)
}
dev.off()
# compare the elongation metrics
res <- list()
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
res[[i]] <- c(elong.samp = elongation.sample(pol, draw = FALSE),
elong.elps = elongation.ellipse(pol, draw = FALSE))
}
res <- plyr::ldply(res)
par(mfrow = c(1,2))
plot(res); abline(a=0, b=1)
boxplot(res)
}
CTR <- readOGR(dsn = "..Data/COUNTRIES", layer = "COUNTRIES")
CTR <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES")
# plot a huge figure with all the polygons and their elongation value
pdf("../Figures/Elongations.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
pol <- CTR[i,]
elong <- elongation.sample(pol, draw = TRUE)
}
dev.off()
# compare the elongation metrics
res <- list()
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
res[[i]] <- c(elong.samp = elongation.sample(pol, draw = FALSE),
elong.elps = elongation.ellipse(pol, draw = FALSE))
}
res <- plyr::ldply(res)
par(mfrow = c(1,2))
plot(res); abline(a=0, b=1)
boxplot(res)
# libraries for working with ellipses (may be useful in the ellongation metrics)
library(cluster) # for the ellipsoid hull funciton
library(car) # another one for ellipses
if(test.on.all.polygons)
{
CTR <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES")
# plot a huge figure with all the polygons and their elongation value
pdf("../Figures/Elongations.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
pol <- CTR[i,]
elong <- elongation.sample(pol, draw = TRUE)
}
dev.off()
# compare the elongation metrics
res <- list()
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
res[[i]] <- c(elong.samp = elongation.sample(pol, draw = FALSE),
elong.elps = elongation.ellipse(pol, draw = FALSE))
}
res <- plyr::ldply(res)
par(mfrow = c(1,2))
plot(res); abline(a=0, b=1)
boxplot(res)
}
CTR <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES")
# plot a huge figure with all the polygons and their elongation value
pdf("../Figures/Elongations.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
pol <- CTR[i,]
elong <- elongation.sample(pol, draw = TRUE)
}
dev.off()
# compare the elongation metrics
res <- list()
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
res[[i]] <- c(elong.samp = elongation.sample(pol, draw = FALSE),
elong.elps = elongation.ellipse(pol, draw = FALSE))
}
res <- plyr::ldply(res)
par(mfrow = c(1,2))
plot(res); abline(a=0, b=1)
boxplot(res)
ISL <- raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/ALL_CLASSES_clean.tif")
ISL <- raster::raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/ALL_CLASSES_clean.tif")
plot(ISL)
source("0_libraries_functions_settings.r")
CTR <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES")
plot(ISL)
ISL <- raster::raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/ALL_CLASSES_clean.tif")
plot(ISL)
source("0_libraries_functions_settings.r")
ISL <- raster::raster("/media/pk33loci/Elements/GIS_data/ISLANDNESS/rasters/ALL_CLASSES_clean.tif")
CTR <- readOGR(dsn = "../Data/COUNTRIES", layer = "COUNTRIES")
?crop
i = 1
pol <- CTR[i,]
extent(pol)
plot(rst, axes = FALSE, box=FALSE, legend=FALSE)
rst <- crop(ISL, y = extent(pol))
plot(rst, axes = FALSE, box=FALSE, legend=FALSE)
plot(pol, add=TRUE)
plot(pol)
plot(rst, axes = FALSE, box=FALSE, legend=FALSE)
plot(pol)
plot(rst, axes = FALSE, box=FALSE, legend=FALSE, add=TRUE)
plot(pol, add=TRUE)
pdf("../Figures/Islandness_polygons.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
pol <- CTR[i,]
rst <- crop(ISL, y = extent(pol))
plot(pol)
plot(rst, axes = FALSE, box=FALSE, legend=FALSE, add=TRUE)
plot(pol, add=TRUE)
}
pdf("../Figures/Islandness_polygons.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
rst <- crop(ISL, y = extent(pol))
plot(pol, main = pol@data$NAME[1])
plot(rst, axes = FALSE, box=FALSE, legend=FALSE, add=TRUE)
plot(pol, add=TRUE)
}
dev.off()
pdf("../Figures/Islandness_polygons.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
# rst <- crop(ISL, y = extent(pol))
plot(pol, main = pol@data$NAME[1])
plot(rst, axes = FALSE, box=FALSE, legend=FALSE, add=TRUE)
plot(pol, add=TRUE)
}
pdf("../Figures/Islandness_polygons.pdf", width = 30, height = 100)
par(mfrow=c(36,10))
for(i in 1:nrow(CTR))
{
print(i)
pol <- CTR[i,]
rst <- crop(ISL, y = extent(pol))
plot(pol, main = pol@data$NAME[1])
plot(rst, axes = FALSE, box=FALSE, legend=FALSE, add=TRUE)
plot(pol, add=TRUE)
}
dev.off()
library(brms)
load("../STAN_models/brms_SMOOTH.RData")
load("../STAN_models/brms_REALM.RData")
objects()
stanplot("brm.REALM")
stanplot(brm.REALM)
